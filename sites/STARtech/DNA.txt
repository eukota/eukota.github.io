import java.applet.*;import java.awt.*;public class DNA extends Applet {	int AMOUNT = 48;//declare number of circles	double[][] points = new double[AMOUNT][7];	int[] order = new int[AMOUNT];	int i,a,x,d,oldx,oldy,dx,dy,curw,curh,p,y,s,t,da,dp,dd;	double b,c,m,an,w;	Image buffer;	public void init()   {	 	resize(200,200);	 	   a = 0;	 	b = 180;	 	c = 90;	 	   for (i=-80;i<=60;i+=20)    {   				points[a][0] = i;		    points[a][1] = 40*Math.cos(b/180*Math.PI);		    points[a][2] = 40*Math.sin(b/180*Math.PI);						a++;			   b += 45;		   	points[a][0] = i;		    points[a][1] = 40*Math.cos(c/180*Math.PI);		    points[a][2] = 40*Math.sin(c/180*Math.PI);		   	a++;		   	c += 45;		 }	 	   a = 0;	 	b = 202.5;	 	c = 112.5;	 	   for (i=-70;i<=70;i+=20)   {		   	points[a+16][0] = i;		    points[a+16][1] = 40*Math.cos(b/180*Math.PI);		    points[a+16][2] = 40*Math.sin(b/180*Math.PI);		   	a++;			   b += 45;			   points[a+16][0] = i;		    points[a+16][1] = 40*Math.cos(c/180*Math.PI);		    points[a+16][2] = 40*Math.sin(c/180*Math.PI);		   	a++;			   c += 45;		 }	 	   for (i=0;i<=15;i=i+2)   {			   points[i+32][0] = points[i][0] + ((points[i+1][0]-points[i][0])/3);			   points[i+32][1] = points[i][1] + ((points[i+1][1]-points[i][1])/3);			   points[i+32][2] = points[i][2] + ((points[i+1][2]-points[i][2])/3);			   points[i+33][0] = points[i][0] + (2*(points[i+1][0]-points[i][0])/3);			   points[i+33][1] = points[i][1] + (2*(points[i+1][1]-points[i][1])/3);			   points[i+33][2] = points[i][2] + (2*(points[i+1][2]-points[i][2])/3);	  }		    for (i=0;i<=15;i++)    {			   points[i][3] = 200;			   points[i][4] = 0;			   points[i][5] = 0;			   points[i][6] = 22;		 }		    for (i=16;i<=31;i++)    {			   points[i][3] = 0;			   points[i][4] = 0;			   points[i][5] = 200;			   points[i][6] = 18;		 }		for (i=32;i<=47;i++) {			a = (int)(4*Math.random());			if (a==0) {				points[i][3] = 100;				points[i][4] = 100;				points[i][5] = 0;			}			   if (a==1)    {				  points[i][3] = 0;			  	points[i][4] = 100;		  		points[i][5] = 0;			}			   if (a==2)    {				  points[i][3] = 0;			  	points[i][4] = 100;			  	points[i][5] = 100;			}			   if (a==3)    {				  points[i][3] = 100;				  points[i][4] = 0;			  	points[i][5] = 100;			}			   points[i][6] = 18;			i++;			a = 3 - a;			   if (a==0)    {			  	points[i][3] = 100;			  	points[i][4] = 100;			  	points[i][5] = 0;			}			   if (a==1)    {			  	points[i][3] = 0;			  	points[i][4] = 100;			  	points[i][5] = 0;			}			    if (a==2)    {			  	points[i][3] = 0;			  	points[i][4] = 100;			  	points[i][5] = 100;	 	}			   if (a==3)    {				  points[i][3] = 100;				  points[i][4] = 0;			  	points[i][5] = 100;			}			points[i][6] = 18;		 }}	****************************** DRAWING SECTION *****public void paint(Graphics g) {		 for (i=0;i<AMOUNT;i++) {			   order[i] = -200;	 	}		    for (i=0;i<AMOUNT;i++)    {			   x = 0;			   for (a=0;a<AMOUNT;a++)       {				     if (points[i][2]>points[a][2])          {					       x++;				     }			   }			      for (x=x;order[x]!=-200;x++)       {			   }			   order[x] = i;		 }		 for (i=0;i<AMOUNT;i++)    {			   if (points[order[i]][3]!=0)       {				     a = (int)(points[order[i]][3]+(points[order[i]][2]/2));				     if (a>255)          {					       a = 255;				     }			      } else {				        a = 0;			      }			      if (points[order[i]][4]!=0) {				p = (int)(points[order[i]][4]+(points[order[i]][2]/2));				if (p>255) {					p = 255;				}			} else {				p = 0;			}			if (points[order[i]][5]!=0) {				d = (int)(points[order[i]][5]+(points[order[i]][2]/2));				if (d>255) {					d = 255;				}			} else {				d = 0;			}			w = (points[order[i]][2]+1000)/1000;			da = 255 - a;			dp = 255 - p;			dd = 255 - d;			s = (int)(points[order[i]][6]*w);			for (t=8;t>=1;t--) {				a = (int)(255 - (da*t/8));				p = (int)(255 - (dp*t/8));				d = (int)(255 - (dd*t/8));				g.setColor(new Color(a,p,d));				x = (int) (w*(points[order[i]][0])+100-(int)(s/2)+((8-t)*s/32));				y = (int) (w*(points[order[i]][1])+100-(int)(s/2)+((8-t)*s/32));				g.fillOval(x,y,t*s/8,t*s/8);			}		}	}		public boolean mouseDown(Event e, int x, int y) {		oldx = x;		oldy = y;		return true;	}		public boolean mouseDrag(Event e, int x, int y) {		dx = x - oldx;		dy = y - oldy;		for (i=0;i<AMOUNT;i++) {			b = points[i][0];			c = points[i][2];			if (c!=0) {				an = 180/Math.PI*(Math.atan(b/c));				if (an==0) {					if (c<0) {						an = 180;					}				}				if (b<0) {					if (c>=0) {						an = an + 360;					} else {						an = an + 180;					}				}				if (c<0) {					if (b>0) {						an = an + 180;					}				}			} else {				if (b>0) {					an = 90;				} else {					an = 270;				}			}			m = Math.sqrt((b*b)+(c*c));			an = an + dx;			b = m*(Math.sin(an/180*Math.PI));			c = m*(Math.cos(an/180*Math.PI));			points[i][0] = b;			points[i][2] = c;		}		for (i=0;i<AMOUNT;i++) {			b = points[i][1];			c = points[i][2];			if (c!=0) {				an = 180/Math.PI*(Math.atan(b/c));				if (an==0) {					if (c<0) {						an = 180;					}				}				if (b<0) {					if (c>=0) {						an = an + 360;					} else {						an = an + 180;					}				}				if (c<0) {					if (b>0) {						an = an + 180;					}				}			} else {				if (b>0) {					an = 90;				} else {					an = 270;				}			}			m = Math.sqrt((b*b)+(c*c));			an = an + dy;			b = m*(Math.sin(an/180*Math.PI));			c = m*(Math.cos(an/180*Math.PI));			points[i][1] = b;			points[i][2] = c;		}		oldx = x;		oldy = y;		if ((buffer==null) || (curw!=size().width) || (curh!=size().height)) {			buffer = createImage(size().width, size().height);		}		Graphics g = buffer.getGraphics();		update(g);		g = getGraphics();		g.drawImage(buffer,0,0,this);		return true;	}}